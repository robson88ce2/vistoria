{"version":3,"sources":["streamlit/ArrowTable.ts","streamlit/streamlit.ts","streamlit/StreamlitReact.tsx","StreamlitCropper.tsx","index.tsx"],"names":["ArrowTable","dataBuffer","indexBuffer","columnsBuffer","styler","_this","_classCallCheck","dataTable","indexTable","columnsTable","getCell","rowIndex","columnIndex","isBlankCell","headerRows","headerColumns","isIndexCell","isColumnsCell","classNames","push","type","join","content","dataColumnIndex","getContent","dataRowIndex","id","concat","uuid","displayValuesTable","table","column","getColumnAt","getColumnTypeId","Type","Timestamp","nanosToDate","get","this","Table","from","caption","styles","undefined","_createClass","key","length","numCols","rows","dataRows","columns","dataColumns","value","schema","fields","typeId","nanos","Date","ComponentMessageType","Streamlit","_class","API_VERSION","RENDER_EVENT","events","EventTarget","registeredMessageListener","lastFrameHeight","setComponentReady","window","addEventListener","onMessageEvent","sendBackMsg","COMPONENT_READY","apiVersion","setFrameHeight","height","document","body","scrollHeight","SET_FRAME_HEIGHT","setComponentValue","SET_COMPONENT_VALUE","event","data","onRenderMessage","args","console","error","dataframeArgs","argsDataframeToObject","_objectSpread","eventData","disabled","Boolean","CustomEvent","detail","dispatchEvent","argsDataframe","argsDataframeArrow","map","_ref","toArrowTable","Object","fromEntries","df","_df$data","index","parent","postMessage","isStreamlitMessage","React","PureComponent","withStreamlitConnection","WrappedComponent","ComponentWrapper","_React$PureComponent2","_inherits","_super2","_createSuper","props","call","componentDidMount","onRenderEvent","componentDidUpdate","state","componentError","componentWillUnmount","removeEventListener","renderEvent","setState","renderData","render","createElement","message","width","innerWidth","getDerivedStateFromError","hoistNonReactStatics","_useState","useState","fabric","Canvas","_useState2","_slicedToArray","canvas","setCanvas","_props$args","canvasWidth","canvasHeight","imageData","invisCanvas","ctx","getContext","idata","createImageData","set","putImageData","dataUri","toDataURL","useEffect","_props$args2","rectTop","rectLeft","rectWidth","rectHeight","boxColor","strokeWidth","lockAspect","enableRetinaScaling","backgroundImage","uniScaleTransform","rect","Rect","left","top","fill","objectCaching","stroke","hasRotatingPoint","add","realtimeUpdate","handleEvent","renderAll","coords","getObjects","getBoundingRect","on","off","Fragment","ReactDOM","StrictMode","StreamlitCropper","getElementById"],"mappings":"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","file":"static/js/main.617173a8.chunk.js","sourcesContent":["/**\r\n * @license\r\n * Copyright 2018-2019 Streamlit Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { Table, Type } from \"apache-arrow\"\r\n\r\ntype CellType = \"blank\" | \"index\" | \"columns\" | \"data\"\r\n\r\nexport interface ArrowDataframeProto {\r\n  data: ArrowTableProto\r\n  height: string\r\n  width: string\r\n}\r\n\r\nexport interface ArrowTableProto {\r\n  data: Uint8Array\r\n  index: Uint8Array\r\n  columns: Uint8Array\r\n  styler: Styler\r\n}\r\n\r\ninterface Cell {\r\n  classNames: string\r\n  content: string\r\n  id?: string\r\n  type: CellType\r\n}\r\n\r\ninterface Styler {\r\n  caption?: string\r\n  displayValuesTable: Table\r\n  styles?: string\r\n  uuid: string\r\n}\r\n\r\nexport class ArrowTable {\r\n  private readonly dataTable: Table\r\n  private readonly indexTable: Table\r\n  private readonly columnsTable: Table\r\n  private readonly styler?: Styler\r\n\r\n  constructor(\r\n    dataBuffer: Uint8Array,\r\n    indexBuffer: Uint8Array,\r\n    columnsBuffer: Uint8Array,\r\n    styler?: any\r\n  ) {\r\n    this.dataTable = Table.from(dataBuffer)\r\n    this.indexTable = Table.from(indexBuffer)\r\n    this.columnsTable = Table.from(columnsBuffer)\r\n    this.styler = styler\r\n      ? {\r\n          caption: styler.get(\"caption\"),\r\n          displayValuesTable: Table.from(styler.get(\"displayValues\")),\r\n          styles: styler.get(\"styles\"),\r\n          uuid: styler.get(\"uuid\"),\r\n        }\r\n      : undefined\r\n  }\r\n\r\n  get rows(): number {\r\n    return this.indexTable.length + this.columnsTable.numCols\r\n  }\r\n\r\n  get columns(): number {\r\n    return this.indexTable.numCols + this.columnsTable.length\r\n  }\r\n\r\n  get headerRows(): number {\r\n    return this.rows - this.dataRows\r\n  }\r\n\r\n  get headerColumns(): number {\r\n    return this.columns - this.dataColumns\r\n  }\r\n\r\n  get dataRows(): number {\r\n    return this.dataTable.length\r\n  }\r\n\r\n  get dataColumns(): number {\r\n    return this.dataTable.numCols\r\n  }\r\n\r\n  get uuid(): string | undefined {\r\n    return this.styler && this.styler.uuid\r\n  }\r\n\r\n  get caption(): string | undefined {\r\n    return this.styler && this.styler.caption\r\n  }\r\n\r\n  get styles(): string | undefined {\r\n    return this.styler && this.styler.styles\r\n  }\r\n\r\n  get table(): Table {\r\n    return this.dataTable\r\n  }\r\n\r\n  get index(): Table {\r\n    return this.indexTable\r\n  }\r\n\r\n  get columnTable(): Table {\r\n    return this.columnsTable\r\n  }\r\n\r\n  public getCell = (rowIndex: number, columnIndex: number): Cell => {\r\n    const isBlankCell =\r\n      rowIndex < this.headerRows && columnIndex < this.headerColumns\r\n    const isIndexCell =\r\n      rowIndex >= this.headerRows && columnIndex < this.headerColumns\r\n    const isColumnsCell =\r\n      rowIndex < this.headerRows && columnIndex >= this.headerColumns\r\n\r\n    if (isBlankCell) {\r\n      const classNames = [\"blank\"]\r\n      if (columnIndex > 0) {\r\n        classNames.push(\"level\" + rowIndex)\r\n      }\r\n\r\n      return {\r\n        type: \"blank\",\r\n        classNames: classNames.join(\" \"),\r\n        content: \"\",\r\n      }\r\n    } else if (isColumnsCell) {\r\n      const dataColumnIndex = columnIndex - this.headerColumns\r\n      const classNames = [\r\n        \"col_heading\",\r\n        \"level\" + rowIndex,\r\n        \"col\" + dataColumnIndex,\r\n      ]\r\n\r\n      return {\r\n        type: \"columns\",\r\n        classNames: classNames.join(\" \"),\r\n        content: this.getContent(this.columnsTable, dataColumnIndex, rowIndex),\r\n      }\r\n    } else if (isIndexCell) {\r\n      const dataRowIndex = rowIndex - this.headerRows\r\n      const classNames = [\r\n        \"row_heading\",\r\n        \"level\" + columnIndex,\r\n        \"row\" + dataRowIndex,\r\n      ]\r\n\r\n      return {\r\n        type: \"index\",\r\n        id: `T_${this.uuid}level${columnIndex}_row${dataRowIndex}`,\r\n        classNames: classNames.join(\" \"),\r\n        content: this.getContent(this.indexTable, dataRowIndex, columnIndex),\r\n      }\r\n    } else {\r\n      const dataRowIndex = rowIndex - this.headerRows\r\n      const dataColumnIndex = columnIndex - this.headerColumns\r\n      const classNames = [\r\n        \"data\",\r\n        \"row\" + dataRowIndex,\r\n        \"col\" + dataColumnIndex,\r\n      ]\r\n      const content = this.styler\r\n        ? this.getContent(\r\n            this.styler.displayValuesTable,\r\n            dataRowIndex,\r\n            dataColumnIndex\r\n          )\r\n        : this.getContent(this.dataTable, dataRowIndex, dataColumnIndex)\r\n\r\n      return {\r\n        type: \"data\",\r\n        id: `T_${this.uuid}row${dataRowIndex}_col${dataColumnIndex}`,\r\n        classNames: classNames.join(\" \"),\r\n        content,\r\n      }\r\n    }\r\n  }\r\n\r\n  public getContent = (\r\n    table: Table,\r\n    rowIndex: number,\r\n    columnIndex: number\r\n  ): any => {\r\n    const column = table.getColumnAt(columnIndex)\r\n    if (column === null) {\r\n      return \"\"\r\n    }\r\n\r\n    const columnTypeId = this.getColumnTypeId(table, columnIndex)\r\n    switch (columnTypeId) {\r\n      case Type.Timestamp: {\r\n        return this.nanosToDate(column.get(rowIndex))\r\n      }\r\n      default: {\r\n        return column.get(rowIndex)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns apache-arrow specific typeId of column.\r\n   */\r\n  private getColumnTypeId(table: Table, columnIndex: number): Type {\r\n    return table.schema.fields[columnIndex].type.typeId\r\n  }\r\n\r\n  private nanosToDate(nanos: number): Date {\r\n    return new Date(nanos / 1e6)\r\n  }\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2018-2020 Streamlit Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Safari doesn't support the EventTarget class, so we use a shim.\r\nimport { EventTarget } from \"event-target-shim\"\r\nimport { ArrowDataframeProto, ArrowTable } from \"./ArrowTable\"\r\n\r\n/** Data sent in the custom Streamlit render event. */\r\nexport interface RenderData {\r\n  args: any\r\n  disabled: boolean\r\n}\r\n\r\n/** Messages from Component -> Streamlit */\r\nenum ComponentMessageType {\r\n  // A component sends this message when it's ready to receive messages\r\n  // from Streamlit. Streamlit won't send any messages until it gets this.\r\n  // Data: { apiVersion: number }\r\n  COMPONENT_READY = \"streamlit:componentReady\",\r\n\r\n  // The component has a new widget value. Send it back to Streamlit, which\r\n  // will then re-run the app.\r\n  // Data: { value: any }\r\n  SET_COMPONENT_VALUE = \"streamlit:setComponentValue\",\r\n\r\n  // The component has a new height for its iframe.\r\n  // Data: { height: number }\r\n  SET_FRAME_HEIGHT = \"streamlit:setFrameHeight\",\r\n}\r\n\r\n/**\r\n * Streamlit communication API.\r\n *\r\n * Components can send data to Streamlit via the functions defined here,\r\n * and receive data from Streamlit via the `events` property.\r\n */\r\nexport class Streamlit {\r\n  /**\r\n   * The Streamlit component API version we're targetting.\r\n   * There's currently only 1!\r\n   */\r\n  public static readonly API_VERSION = 1\r\n\r\n  public static readonly RENDER_EVENT = \"streamlit:render\"\r\n\r\n  /** Dispatches events received from Streamlit. */\r\n  public static readonly events = new EventTarget()\r\n\r\n  private static registeredMessageListener = false\r\n  private static lastFrameHeight?: number\r\n\r\n  /**\r\n   * Tell Streamlit that the component is ready to start receiving data.\r\n   * Streamlit will defer emitting RENDER events until it receives the\r\n   * COMPONENT_READY message.\r\n   */\r\n  public static setComponentReady = (): void => {\r\n    if (!Streamlit.registeredMessageListener) {\r\n      // Register for message events if we haven't already\r\n      window.addEventListener(\"message\", Streamlit.onMessageEvent)\r\n      Streamlit.registeredMessageListener = true\r\n    }\r\n\r\n    Streamlit.sendBackMsg(ComponentMessageType.COMPONENT_READY, {\r\n      apiVersion: Streamlit.API_VERSION,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Report the component's height to Streamlit.\r\n   * This should be called every time the component changes its DOM - that is,\r\n   * when it's first loaded, and any time it updates.\r\n   */\r\n  public static setFrameHeight = (height?: number): void => {\r\n    if (height === undefined) {\r\n      // `height` is optional. If undefined, it defaults to scrollHeight,\r\n      // which is the entire height of the element minus its border,\r\n      // scrollbar, and margin.\r\n      height = document.body.scrollHeight\r\n    }\r\n\r\n    if (height === Streamlit.lastFrameHeight) {\r\n      // Don't bother updating if our height hasn't changed.\r\n      return\r\n    }\r\n\r\n    Streamlit.lastFrameHeight = height\r\n    Streamlit.sendBackMsg(ComponentMessageType.SET_FRAME_HEIGHT, { height })\r\n  }\r\n\r\n  /**\r\n   * Set the component's value. This value will be returned to the Python\r\n   * script, and the script will be re-run.\r\n   *\r\n   * For example:\r\n   *\r\n   * JavaScript:\r\n   * Streamlit.setComponentValue(\"ahoy!\")\r\n   *\r\n   * Python:\r\n   * value = st.my_component(...)\r\n   * st.write(value) # -> \"ahoy!\"\r\n   *\r\n   * The value must be serializable into JSON.\r\n   */\r\n  public static setComponentValue = (value: any): void => {\r\n    Streamlit.sendBackMsg(ComponentMessageType.SET_COMPONENT_VALUE, { value })\r\n  }\r\n\r\n  /** Receive a ForwardMsg from the Streamlit app */\r\n  private static onMessageEvent = (event: MessageEvent): void => {\r\n    const type = event.data[\"type\"]\r\n    switch (type) {\r\n      case Streamlit.RENDER_EVENT:\r\n        Streamlit.onRenderMessage(event.data)\r\n        break\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle an untyped Streamlit render event and redispatch it as a\r\n   * StreamlitRenderEvent.\r\n   */\r\n  private static onRenderMessage = (data: any): void => {\r\n    let args = data[\"args\"]\r\n    if (args == null) {\r\n      console.error(\r\n        `Got null args in onRenderMessage. This should never happen`\r\n      )\r\n      args = {}\r\n    }\r\n\r\n    // Parse our dataframe arguments with arrow, and merge them into our args dict\r\n    const dataframeArgs =\r\n      data[\"dfs\"] && data[\"dfs\"].length > 0\r\n        ? Streamlit.argsDataframeToObject(data[\"dfs\"])\r\n        : {}\r\n\r\n    args = {\r\n      ...args,\r\n      ...dataframeArgs,\r\n    }\r\n\r\n    const disabled = Boolean(data[\"disabled\"])\r\n\r\n    // Dispatch a render event!\r\n    const eventData = { disabled, args }\r\n    const event = new CustomEvent<RenderData>(Streamlit.RENDER_EVENT, {\r\n      detail: eventData,\r\n    })\r\n    Streamlit.events.dispatchEvent(event)\r\n  }\r\n\r\n  private static argsDataframeToObject = (\r\n    argsDataframe: ArgsDataframe[]\r\n  ): object => {\r\n    const argsDataframeArrow = argsDataframe.map(\r\n      ({ key, value }: ArgsDataframe) => [key, Streamlit.toArrowTable(value)]\r\n    )\r\n    return Object.fromEntries(argsDataframeArrow)\r\n  }\r\n\r\n  private static toArrowTable = (df: ArrowDataframeProto): ArrowTable => {\r\n    const { data, index, columns } = df.data\r\n    return new ArrowTable(data, index, columns)\r\n  }\r\n\r\n  /** Post a message to the Streamlit app. */\r\n  private static sendBackMsg = (type: string, data?: any): void => {\r\n    window.parent.postMessage(\r\n      {\r\n        isStreamlitMessage: true,\r\n        type: type,\r\n        ...data,\r\n      },\r\n      \"*\"\r\n    )\r\n  }\r\n}\r\n\r\ninterface ArgsDataframe {\r\n  key: string\r\n  value: ArrowDataframeProto\r\n}\r\n","import hoistNonReactStatics from \"hoist-non-react-statics\"\r\nimport React, { ReactNode } from \"react\"\r\nimport { RenderData, Streamlit } from \"./streamlit\"\r\n\r\n/**\r\n * Props passed to custom Streamlit components.\r\n */\r\nexport interface ComponentProps {\r\n  /** Named dictionary of arguments passed from Python. */\r\n  args: any\r\n\r\n  /** The component's width. */\r\n  width: number\r\n\r\n  /**\r\n   * True if the component should be disabled.\r\n   * All components get disabled while the app is being re-run,\r\n   * and become re-enabled when the re-run has finished.\r\n   */\r\n  disabled: boolean\r\n}\r\n\r\n/**\r\n * Optional Streamlit React-based component base class.\r\n *\r\n * You are not required to extend this base class to create a Streamlit\r\n * component. If you decide not to extend it, you should implement the\r\n * `componentDidMount` and `componentDidUpdate` functions in your own class,\r\n * so that your plugin properly resizes.\r\n */\r\nexport class StreamlitComponentBase<S = {}> extends React.PureComponent<\r\n  ComponentProps,\r\n  S\r\n> {\r\n  public componentDidMount(): void {\r\n    // After we're rendered for the first time, tell Streamlit that our height\r\n    // has changed.\r\n    Streamlit.setFrameHeight()\r\n  }\r\n\r\n  public componentDidUpdate(): void {\r\n    // After we're updated, tell Streamlit that our height may have changed.\r\n    Streamlit.setFrameHeight()\r\n  }\r\n}\r\n\r\n/**\r\n * Wrapper for React-based Streamlit components.\r\n *\r\n * Bootstraps the communication interface between Streamlit and the component.\r\n */\r\nexport function withStreamlitConnection(\r\n  WrappedComponent: React.ComponentType<ComponentProps>\r\n): React.ComponentType {\r\n  interface WrapperProps {}\r\n\r\n  interface WrapperState {\r\n    renderData?: RenderData\r\n    componentError?: Error\r\n  }\r\n\r\n  class ComponentWrapper extends React.PureComponent<\r\n    WrapperProps,\r\n    WrapperState\r\n  > {\r\n    public constructor(props: WrapperProps) {\r\n      super(props)\r\n      this.state = {\r\n        renderData: undefined,\r\n        componentError: undefined,\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Error boundary function. This will be called if our wrapped\r\n     * component throws an error. We store the caught error in our state,\r\n     * and display it in the next render().\r\n     */\r\n    public static getDerivedStateFromError = (\r\n      error: Error\r\n    ): Partial<WrapperState> => {\r\n      return { componentError: error }\r\n    }\r\n\r\n    public componentDidMount = (): void => {\r\n      // Set up event listeners, and signal to Streamlit that we're ready.\r\n      // We won't render the component until we receive the first RENDER_EVENT.\r\n      Streamlit.events.addEventListener(\r\n        Streamlit.RENDER_EVENT,\r\n        this.onRenderEvent\r\n      )\r\n      Streamlit.setComponentReady()\r\n    }\r\n\r\n    public componentDidUpdate = (): void => {\r\n      // If our child threw an error, we display it in render(). In this\r\n      // case, the child won't be mounted and therefore won't call\r\n      // `setFrameHeight` on its own. We do it here so that the rendered\r\n      // error will be visible.\r\n      if (this.state.componentError != null) {\r\n        Streamlit.setFrameHeight()\r\n      }\r\n    }\r\n\r\n    public componentWillUnmount = (): void => {\r\n      Streamlit.events.removeEventListener(\r\n        Streamlit.RENDER_EVENT,\r\n        this.onRenderEvent\r\n      )\r\n    }\r\n\r\n    /**\r\n     * Streamlit is telling this component to redraw.\r\n     * We save the render data in State, so that it can be passed to the\r\n     * component in our own render() function.\r\n     */\r\n    private onRenderEvent = (event: Event): void => {\r\n      // Update our state with the newest render data\r\n      const renderEvent = event as CustomEvent<RenderData>\r\n      this.setState({ renderData: renderEvent.detail })\r\n    }\r\n\r\n    public render = (): ReactNode => {\r\n      // If our wrapped component threw an error, display it.\r\n      if (this.state.componentError != null) {\r\n        return (\r\n          <div>\r\n            <h1>Component Error</h1>\r\n            <span>{this.state.componentError.message}</span>\r\n          </div>\r\n        )\r\n      }\r\n\r\n      // Don't render until we've gotten our first RENDER_EVENT from Streamlit.\r\n      if (this.state.renderData == null) {\r\n        return null\r\n      }\r\n\r\n      return (\r\n        <WrappedComponent\r\n          width={window.innerWidth}\r\n          disabled={this.state.renderData.disabled}\r\n          args={this.state.renderData.args}\r\n        />\r\n      )\r\n    }\r\n  }\r\n\r\n  return hoistNonReactStatics(ComponentWrapper, WrappedComponent)\r\n}\r\n","import React, {useEffect, useState} from 'react';\r\nimport {ComponentProps, Streamlit, withStreamlitConnection} from \"./streamlit\";\r\nimport {fabric} from 'fabric';\r\n\r\ninterface PythonArgs {\r\n    canvasWidth: number\r\n    canvasHeight: number\r\n    rectTop: number\r\n    rectLeft: number\r\n    rectWidth: number\r\n    rectHeight: number\r\n    realtimeUpdate: boolean\r\n    boxColor: string\r\n    strokeWidth: number\r\n    imageData: Uint8ClampedArray\r\n    lockAspect: boolean\r\n}\r\n\r\n\r\nconst StreamlitCropper = (props: ComponentProps) => {\r\n    const [canvas, setCanvas] = useState(new fabric.Canvas(\"\"))\r\n    const {canvasWidth, canvasHeight, imageData}: PythonArgs = props.args\r\n    /*\r\n    * Translate Python image data to a JavaScript Image\r\n    */\r\n    var invisCanvas = document.createElement(\"canvas\")\r\n    var ctx = invisCanvas.getContext('2d')\r\n\r\n    invisCanvas.width = canvasWidth\r\n    invisCanvas.height = canvasHeight\r\n\r\n    // create imageData object\r\n    if (ctx) {\r\n    var idata = ctx.createImageData(canvasWidth, canvasHeight);\r\n\r\n    // set our buffer as source\r\n    idata.data.set(imageData);\r\n\r\n    // update canvas with new data\r\n    ctx.putImageData(idata, 0, 0);\r\n    var dataUri = invisCanvas.toDataURL()\r\n    }\r\n    else {\r\n        // eslint-disable-next-line\r\n        var dataUri = \"\"\r\n    }\r\n    \r\n    /**\r\n     * Initialize canvas on mount and add a rectangle\r\n     */\r\n    useEffect  (() => {\r\n        const {rectTop, rectLeft, rectWidth, rectHeight, boxColor, strokeWidth, lockAspect}: PythonArgs = props.args\r\n        const canvas = new fabric.Canvas('c', {\r\n            enableRetinaScaling: false,\r\n            backgroundImage: dataUri,\r\n            uniScaleTransform: lockAspect\r\n        })\r\n\r\n        var rect = new fabric.Rect({\r\n            left: rectLeft,\r\n            top: rectTop,\r\n            fill: '',\r\n            width: rectWidth,\r\n            height: rectHeight,\r\n            objectCaching: true,\r\n            stroke: boxColor,\r\n            strokeWidth: strokeWidth,\r\n            hasRotatingPoint: false\r\n\r\n          });\r\n        canvas.add(rect)\r\n\r\n        setCanvas(canvas)\r\n        Streamlit.setFrameHeight()\r\n        // eslint-disable-next-line\r\n    }, [canvasHeight, canvasWidth]);\r\n\r\n\r\n    /**\r\n     * On update (either realtime or doubleclick), send the coordinates of the rectangle\r\n     * back to streamlit.\r\n     */\r\n    useEffect(() => {\r\n        const {realtimeUpdate}: PythonArgs = props.args\r\n        if (!canvas) {\r\n            return;\r\n        }\r\n        const handleEvent = () => {\r\n            canvas.renderAll()\r\n            const coords = canvas.getObjects()[0].getBoundingRect()\r\n            Streamlit.setComponentValue({coords:coords})\r\n        }\r\n        \r\n        if (realtimeUpdate) {\r\n        canvas.on(\"object:modified\", handleEvent)\r\n        return () => {\r\n            canvas.off(\"object:modified\");\r\n        }\r\n        }\r\n        else {\r\n        canvas.on(\"mouse:dblclick\", handleEvent)\r\n        return () => {\r\n            canvas.off(\"mouse:dblclick\");\r\n        }\r\n        }\r\n    })\r\n\r\n    return (\r\n        <>\r\n            <canvas id=\"c\" width={canvasWidth} height={canvasHeight}/>\r\n        </>\r\n    )\r\n};\r\n\r\nexport default withStreamlitConnection(StreamlitCropper);\r\n","import React from \"react\"\r\nimport ReactDOM from \"react-dom\"\r\nimport StreamlitCropper from \"./StreamlitCropper\"\r\n\r\nimport \"./index.css\"\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <StreamlitCropper />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n)\r\n"],"sourceRoot":""}